=== DEBUG REPORT ===

=== 1) Arborescence compl√®te du projet ===

=== 2) Fichiers contenant 'db.js' ===
/home/labo/Bureau/Projet_Web/event-backend/src/authController.js:11:import pool from "../db.js";
/home/labo/Bureau/Projet_Web/event-backend/src/createUser.js:7:import pool from "../db.js";       // Connexion PostgreSQL
/home/labo/Bureau/Projet_Web/event-backend/userManager.js:3:import pool from "././src/db.js";
/home/labo/Bureau/Projet_Web/event-backend/node_modules/pg-pool/README.md:193:// assume this is a file in your program at ./your-app/lib/db.js
/home/labo/Bureau/Projet_Web/event-backend/node_modules/mime-db/package.json:40:    "db.json",
/home/labo/Bureau/Projet_Web/event-backend/node_modules/mime-db/index.js:12:module.exports = require('./db.json')
/home/labo/Bureau/Projet_Web/event-backend/node_modules/mime-db/README.md:29:https://cdn.jsdelivr.net/gh/jshttp/mime-db@master/db.json
/home/labo/Bureau/Projet_Web/script/generate_debug_report.sh:12:echo "=== 2) Fichiers contenant 'db.js' ===" >> $OUTPUT
/home/labo/Bureau/Projet_Web/script/generate_debug_report.sh:13:grep -RIn "db.js" ~/Bureau/Projet_Web >> $OUTPUT 2>/dev/null
/home/labo/Bureau/Projet_Web/script/generate_debug_report.sh:18:FILES=$(grep -RIl "db.js" ~/Bureau/Projet_Web)

=== 3) Contenu des fichiers suspects ===
--- /home/labo/Bureau/Projet_Web/event-backend/src/authController.js ---
// Importation de bcrypt : sert √† hasher les mots de passe
// ‚Üí On ne stocke jamais un mot de passe en clair dans la base
import bcrypt from "bcryptjs";

// Importation de jsonwebtoken : sert √† cr√©er et v√©rifier les tokens JWT
// ‚Üí Le token permet d'identifier un utilisateur connect√©
import jwt from "jsonwebtoken";

// Importation du pool PostgreSQL (connexion √† la base)
// ‚Üí pool.query() permet d'ex√©cuter des requ√™tes SQL
import pool from "../db.js";

// Importation de dotenv : permet de lire les variables du fichier .env
import dotenv from "dotenv";

// Charge les variables du fichier .env dans process.env
dotenv.config();

// R√©cup√©ration de la cl√© secr√®te utilis√©e pour signer les tokens JWT
// ‚Üí Cette cl√© doit rester secr√®te et ne jamais √™tre dans le code
const JWT_SECRET = process.env.JWT_SECRET;



// ======================================================
//   INSCRIPTION (signup)
// ======================================================

// Fonction appel√©e quand un utilisateur veut cr√©er un compte
export const signup = async (req, res) => {
  // R√©cup√©ration des donn√©es envoy√©es par le frontend
  const { username, password } = req.body;

  try {
    // V√©rifie que les deux champs sont bien fournis
    if (!username || !password) {
      return res.status(400).json({ error: "Missing username or password" });
    }

    // V√©rifie si un utilisateur avec ce username existe d√©j√†
    // $1 = premier param√®tre du tableau [username]
    const existingUser = await pool.query(
      "SELECT * FROM users WHERE username = $1",
      [username]
    );

    // Si un utilisateur existe d√©j√†, on bloque l'inscription
    if (existingUser.rows.length > 0) {
      return res.status(400).json({ error: "User already exists" });
    }

    // Hashage du mot de passe
    // 10 = nombre de "rounds" de s√©curit√©
    const hashedPassword = await bcrypt.hash(password, 10);

    // Insertion du nouvel utilisateur dans la base
    // RETURNING permet de r√©cup√©rer l'id et le username cr√©√©s
    const newUser = await pool.query(
      "INSERT INTO users (username, password) VALUES ($1, $2) RETURNING id, username",
      [username, hashedPassword]
    );

    // Cr√©ation d'un token JWT contenant l'id et le username
    // expiresIn: "7d" ‚Üí le token expire dans 7 jours
    const token = jwt.sign(
      { id: newUser.rows[0].id, username: newUser.rows[0].username },
      JWT_SECRET,
      { expiresIn: "7d" }
    );

    // R√©ponse envoy√©e au frontend
    res.json({
      message: "User created successfully",
      token,
      user: newUser.rows[0],
    });

  } catch (err) {
    // Si une erreur survient, on l'affiche dans la console
    console.error("Signup error:", err);

    // Et on renvoie une erreur g√©n√©rique au frontend
    res.status(500).json({ error: "Internal server error" });
  }
};



// ======================================================
//   CONNEXION (login)
// ======================================================

// Fonction appel√©e quand un utilisateur veut se connecter
export const login = async (req, res) => {
  const { username, password } = req.body;

  try {
    // V√©rifie que les champs sont fournis
    if (!username || !password) {
      return res.status(400).json({ error: "Missing username or password" });
    }

    // Recherche de l'utilisateur dans la base
    const user = await pool.query(
      "SELECT * FROM users WHERE username = $1",
      [username]
    );

    // Si aucun utilisateur trouv√© ‚Üí identifiants invalides
    if (user.rows.length === 0) {
      return res.status(400).json({ error: "Invalid credentials" });
    }

    // On r√©cup√®re l'utilisateur trouv√©
    const storedUser = user.rows[0];

    // V√©rifie si le mot de passe fourni correspond au hash stock√©
    const isMatch = await bcrypt.compare(password, storedUser.password);

    // Si le mot de passe ne correspond pas ‚Üí erreur
    if (!isMatch) {
      return res.status(400).json({ error: "Invalid credentials" });
    }

    // G√©n√©ration d'un token JWT pour cet utilisateur
    const token = jwt.sign(
      { id: storedUser.id, username: storedUser.username },
      JWT_SECRET,
      { expiresIn: "7d" }
    );

    // R√©ponse envoy√©e au frontend
    res.json({
      message: "Login successful",
      token,
      user: { id: storedUser.id, username: storedUser.username },
    });

  } catch (err) {
    console.error("Login error:", err);
    res.status(500).json({ error: "Internal server error" });
  }
};



// ======================================================
//   PROFIL UTILISATEUR (prot√©g√© par requireAuth)
// ======================================================

// Cette route renvoie les infos de l'utilisateur connect√©
// requireAuth ajoute req.user automatiquement
export const getProfile = async (req, res) => {
  try {
    res.json({
      message: "Authenticated user",
      user: req.user, // Contient { id, username }
    });
  } catch (err) {
    res.status(500).json({ error: "Internal server error" });
  }
};

--- /home/labo/Bureau/Projet_Web/event-backend/src/createUser.js ---
// Script interne permettant √† un d√©veloppeur de cr√©er un utilisateur manuellement
// ------------------------------------------------------------------------------

// Importation des modules n√©cessaires
import readline from "readline";   // Pour lire les entr√©es clavier
import bcrypt from "bcryptjs";     // Pour hasher le mot de passe
import pool from "../db.js";       // Connexion PostgreSQL

// Interface pour lire les entr√©es utilisateur dans le terminal
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

// Fonction utilitaire pour poser une question dans le terminal
function ask(question) {
  return new Promise((resolve) => rl.question(question, resolve));
}

async function createUser() {
  console.log("=== Cr√©ation d'un utilisateur ===");

  try {
    // Demande du username
    const username = await ask("Nom d'utilisateur : ");

    // Demande du mot de passe
    const password = await ask("Mot de passe : ");

    // Hashage du mot de passe
    const hashedPassword = await bcrypt.hash(password, 10);

    // Insertion dans la base PostgreSQL
    const result = await pool.query(
      "INSERT INTO users (username, password) VALUES ($1, $2) RETURNING id, username",
      [username, hashedPassword]
    );

    console.log("\n‚úî Utilisateur cr√©√© avec succ√®s !");
    console.log("ID :", result.rows[0].id);
    console.log("Username :", result.rows[0].username);
  } catch (err) {
    console.error("‚ùå Erreur lors de la cr√©ation :", err.message);
  } finally {
    rl.close();   // Ferme l‚Äôinterface terminal
    pool.end();   // Ferme la connexion PostgreSQL
  }
}

// Lancement du script
createUser();

--- /home/labo/Bureau/Projet_Web/event-backend/userManager.js ---
import readline from "readline";
import bcrypt from "bcryptjs";
import pool from "././src/db.js";

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

function ask(q) {
  return new Promise(resolve => rl.question(q, resolve));
}

async function createUser() {
  const username = await ask("Nom d'utilisateur : ");
  const password = await ask("Mot de passe : ");

  try {
    const hashed = await bcrypt.hash(password, 10);
    await pool.query(
      "INSERT INTO users (username, password) VALUES ($1, $2)",
      [username, hashed]
    );
    console.log(`‚úîÔ∏è Utilisateur cr√©√© : ${username}`);
  } catch (err) {
    console.error("‚ùå Erreur :", err.message);
  }
}

async function deleteUser() {
  const username = await ask("Nom d'utilisateur √† supprimer : ");

  try {
    const res = await pool.query(
      "DELETE FROM users WHERE username=$1 RETURNING *",
      [username]
    );

    if (res.rowCount === 0) {
      console.log("‚ùå Aucun utilisateur trouv√©.");
    } else {
      console.log(`‚úîÔ∏è Utilisateur supprim√© : ${username}`);
    }
  } catch (err) {
    console.error("‚ùå Erreur :", err.message);
  }
}

async function testUsers() {
  try {
    const res = await pool.query("SELECT username FROM users");

    if (res.rows.length === 0) {
      console.log("‚ö†Ô∏è Aucun utilisateur dans la base.");
      return;
    }

    console.log("\n=== Test des utilisateurs ===");

    for (const row of res.rows) {
      const username = row.username;
      const password = username.replace("user", "pass"); // logique simple

      const userRes = await pool.query(
        "SELECT * FROM users WHERE username=$1",
        [username]
      );

      const user = userRes.rows[0];
      const ok = await bcrypt.compare(password, user.password);

      if (ok) console.log(`‚úîÔ∏è Connexion OK : ${username}`);
      else console.log(`‚ùå Mot de passe incorrect : ${username}`);
    }
  } catch (err) {
    console.error("‚ùå Erreur :", err.message);
  }
}

async function mainMenu() {
  console.log(`
=========================================
   üß™ Gestion des utilisateurs Projetweb
=========================================
1) Cr√©er un utilisateur
2) Supprimer un utilisateur
3) Tester les utilisateurs
4) Quitter
`);

  const choice = await ask("Choix : ");

  switch (choice.trim()) {
    case "1":
      await createUser();
      break;
    case "2":
      await deleteUser();
      break;
    case "3":
      await testUsers();
      break;
    case "4":
      console.log("Au revoir !");
      rl.close();
      process.exit(0);
    default:
      console.log("‚ùå Choix invalide.");
  }

  mainMenu();
}

mainMenu();


--- /home/labo/Bureau/Projet_Web/event-backend/node_modules/pg-pool/README.md ---
# pg-pool
[![Build Status](https://travis-ci.org/brianc/node-pg-pool.svg?branch=master)](https://travis-ci.org/brianc/node-pg-pool)

A connection pool for node-postgres

## install
```sh
npm i pg-pool pg
```

## use

### create

to use pg-pool you must first create an instance of a pool

```js
const Pool = require('pg-pool')

// by default the pool uses the same
// configuration as whatever `pg` version you have installed
const pool = new Pool()

// you can pass properties to the pool
// these properties are passed unchanged to both the node-postgres Client constructor
// and the node-pool (https://github.com/coopernurse/node-pool) constructor
// allowing you to fully configure the behavior of both
const pool2 = new Pool({
  database: 'postgres',
  user: 'brianc',
  password: 'secret!',
  port: 5432,
  ssl: true,
  max: 20, // set pool max size to 20
  idleTimeoutMillis: 1000, // close idle clients after 1 second
  connectionTimeoutMillis: 1000, // return an error after 1 second if connection could not be established
  maxUses: 7500, // close (and replace) a connection after it has been used 7500 times (see below for discussion)
})

// you can supply a custom client constructor
// if you want to use the native postgres client
const NativeClient = require('pg').native.Client
const nativePool = new Pool({ Client: NativeClient })

// you can even pool pg-native clients directly
const PgNativeClient = require('pg-native')
const pgNativePool = new Pool({ Client: PgNativeClient })
```

##### Note:
The Pool constructor does not support passing a Database URL as the parameter. To use pg-pool on heroku, for example, you need to parse the URL into a config object. Here is an example of how to parse a Database URL.

```js
const Pool = require('pg-pool');
const url = require('url')

const params = url.parse(process.env.DATABASE_URL);
const auth = params.auth.split(':');

const config = {
  user: auth[0],
  password: auth[1],
  host: params.hostname,
  port: params.port,
  database: params.pathname.split('/')[1],
  ssl: true
};

const pool = new Pool(config);

/*
  Transforms, 'postgres://DBuser:secret@DBHost:#####/myDB', into
  config = {
    user: 'DBuser',
    password: 'secret',
    host: 'DBHost',
    port: '#####',
    database: 'myDB',
    ssl: true
  }
*/
``` 

### acquire clients with a promise

pg-pool supports a fully promise-based api for acquiring clients

```js
const pool = new Pool()
pool.connect().then(client => {
  client.query('select $1::text as name', ['pg-pool']).then(res => {
    client.release()
    console.log('hello from', res.rows[0].name)
  })
  .catch(e => {
    client.release()
    console.error('query error', e.message, e.stack)
  })
})
```

### plays nice with async/await

this ends up looking much nicer if you're using [co](https://github.com/tj/co) or async/await:

```js
// with async/await
(async () => {
  const pool = new Pool()
  const client = await pool.connect()
  try {
    const result = await client.query('select $1::text as name', ['brianc'])
    console.log('hello from', result.rows[0])
  } finally {
    client.release()
  }
})().catch(e => console.error(e.message, e.stack))

// with co
co(function * () {
  const client = yield pool.connect()
  try {
    const result = yield client.query('select $1::text as name', ['brianc'])
    console.log('hello from', result.rows[0])
  } finally {
    client.release()
  }
}).catch(e => console.error(e.message, e.stack))
```

### your new favorite helper method

because its so common to just run a query and return the client to the pool afterward pg-pool has this built-in:

```js
const pool = new Pool()
const time = await pool.query('SELECT NOW()')
const name = await pool.query('select $1::text as name', ['brianc'])
console.log(name.rows[0].name, 'says hello at', time.rows[0].now)
```

you can also use a callback here if you'd like:

```js
const pool = new Pool()
pool.query('SELECT $1::text as name', ['brianc'], function (err, res) {
  console.log(res.rows[0].name) // brianc
})
```

__pro tip:__ unless you need to run a transaction (which requires a single client for multiple queries) or you
have some other edge case like [streaming rows](https://github.com/brianc/node-pg-query-stream) or using a [cursor](https://github.com/brianc/node-pg-cursor)
you should almost always just use `pool.query`.  Its easy, it does the right thing :tm:, and wont ever forget to return
clients back to the pool after the query is done.

### drop-in backwards compatible

pg-pool still and will always support the traditional callback api for acquiring a client.  This is the exact API node-postgres has shipped with for years:

```js
const pool = new Pool()
pool.connect((err, client, done) => {
  if (err) return done(err)

  client.query('SELECT $1::text as name', ['pg-pool'], (err, res) => {
    done()
    if (err) {
      return console.error('query error', err.message, err.stack)
    }
    console.log('hello from', res.rows[0].name)
  })
})
```

### shut it down

When you are finished with the pool if all the clients are idle the pool will close them after `config.idleTimeoutMillis` and your app
will shutdown gracefully.  If you don't want to wait for the timeout you can end the pool as follows:

```js
const pool = new Pool()
const client = await pool.connect()
console.log(await client.query('select now()'))
client.release()
await pool.end()
```

### a note on instances

The pool should be a __long-lived object__ in your application.  Generally you'll want to instantiate one pool when your app starts up and use the same instance of the pool throughout the lifetime of your application.  If you are frequently creating a new pool within your code you likely don't have your pool initialization code in the correct place.  Example:

```js
// assume this is a file in your program at ./your-app/lib/db.js

// correct usage: create the pool and let it live
// 'globally' here, controlling access to it through exported methods
const pool = new pg.Pool()

// this is the right way to export the query method
module.exports.query = (text, values) => {

--- /home/labo/Bureau/Projet_Web/event-backend/node_modules/mime-db/package.json ---
{
  "name": "mime-db",
  "description": "Media Type Database",
  "version": "1.54.0",
  "contributors": [
    "Douglas Christopher Wilson <doug@somethingdoug.com>",
    "Jonathan Ong <me@jongleberry.com> (http://jongleberry.com)",
    "Robert Kieffer <robert@broofa.com> (http://github.com/broofa)"
  ],
  "license": "MIT",
  "keywords": [
    "mime",
    "db",
    "type",
    "types",
    "database",
    "charset",
    "charsets"
  ],
  "repository": "jshttp/mime-db",
  "devDependencies": {
    "csv-parse": "4.16.3",
    "eslint": "8.32.0",
    "eslint-config-standard": "15.0.1",
    "eslint-plugin-import": "2.27.5",
    "eslint-plugin-markdown": "3.0.0",
    "eslint-plugin-node": "11.1.0",
    "eslint-plugin-promise": "6.1.1",
    "eslint-plugin-standard": "4.1.0",
    "media-typer": "1.1.0",
    "mocha": "10.2.0",
    "nyc": "15.1.0",
    "stream-to-array": "2.3.0",
    "undici": "7.1.0"
  },
  "files": [
    "HISTORY.md",
    "LICENSE",
    "README.md",
    "db.json",
    "index.js"
  ],
  "engines": {
    "node": ">= 0.6"
  },
  "scripts": {
    "build": "node scripts/build",
    "fetch": "node scripts/fetch-apache && node scripts/fetch-iana && node scripts/fetch-nginx",
    "lint": "eslint .",
    "test": "mocha --reporter spec --check-leaks test/",
    "test-ci": "nyc --reporter=lcovonly --reporter=text npm test",
    "test-cov": "nyc --reporter=html --reporter=text npm test",
    "update": "npm run fetch && npm run build",
    "version": "node scripts/version-history.js && git add HISTORY.md"
  }
}

--- /home/labo/Bureau/Projet_Web/event-backend/node_modules/mime-db/index.js ---
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = require('./db.json')

--- /home/labo/Bureau/Projet_Web/event-backend/node_modules/mime-db/README.md ---
# mime-db

[![NPM Version][npm-version-image]][npm-url]
[![NPM Downloads][npm-downloads-image]][npm-url]
[![Node.js Version][node-image]][node-url]
[![Build Status][ci-image]][ci-url]
[![Coverage Status][coveralls-image]][coveralls-url]

This is a large database of mime types and information about them.
It consists of a single, public JSON file and does not include any logic,
allowing it to remain as un-opinionated as possible with an API.
It aggregates data from the following sources:

- https://www.iana.org/assignments/media-types/media-types.xhtml
- https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types
- https://hg.nginx.org/nginx/raw-file/default/conf/mime.types

## Installation

```bash
npm install mime-db
```

### Database Download

If you intend to use this in a web browser, you can conveniently access the JSON file via [jsDelivr](https://www.jsdelivr.com/), a popular CDN (Content Delivery Network). To ensure stability and compatibility, it is advisable to specify [a release tag](https://github.com/jshttp/mime-db/tags) instead of using the 'master' branch. This is because the JSON file's format might change in future updates, and relying on a specific release tag will prevent potential issues arising from these changes.

```
https://cdn.jsdelivr.net/gh/jshttp/mime-db@master/db.json
```

## Usage

```js
var db = require('mime-db')

// grab data on .js files
var data = db['application/javascript']
```

## Data Structure

The JSON file is a map lookup for lowercased mime types.
Each mime type has the following properties:

- `.source` - where the mime type is defined.
    If not set, it's probably a custom media type.
    - `apache` - [Apache common media types](https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types)
    - `iana` - [IANA-defined media types](https://www.iana.org/assignments/media-types/media-types.xhtml)
    - `nginx` - [nginx media types](https://hg.nginx.org/nginx/raw-file/default/conf/mime.types)
- `.extensions[]` - known extensions associated with this mime type.
- `.compressible` - whether a file of this type can be gzipped.
- `.charset` - the default charset associated with this type, if any.

If unknown, every property could be `undefined`.

## Note on MIME Type Data and Semver

This package considers the programmatic api as the semver compatibility. This means the MIME type resolution is *not* considered
in the semver bumps. This means that if you want to pin your `mime-db` data you will need to do it in your application. While
this expectation was not set in docs until now, it is how the pacakge operated, so we do not feel this is a breaking change.

## Contributing

The primary way to contribute to this database is by updating the data in
one of the upstream sources. The database is updated from the upstreams
periodically and will pull in any changes.

### Registering Media Types

The best way to get new media types included in this library is to register
them with the IANA. The community registration procedure is outlined in
[RFC 6838 section 5](https://tools.ietf.org/html/rfc6838#section-5). Types
registered with the IANA are automatically pulled into this library.

### Direct Inclusion

If that is not possible / feasible, they can be added directly here as a
"custom" type. To do this, it is required to have a primary source that
definitively lists the media type. If an extension is going to be listed as
associated with this media type, the source must definitively link the
media type and extension as well.

To edit the database, only make PRs against `src/custom-types.json` or
`src/custom-suffix.json`.

The `src/custom-types.json` file is a JSON object with the MIME type as the
keys and the values being an object with the following keys:

- `compressible` - leave out if you don't know, otherwise `true`/`false` to
  indicate whether the data represented by the type is typically compressible.
- `extensions` - include an array of file extensions that are associated with
  the type.
- `notes` - human-readable notes about the type, typically what the type is.
- `sources` - include an array of URLs of where the MIME type and the associated
  extensions are sourced from. This needs to be a [primary source](https://en.wikipedia.org/wiki/Primary_source);
  links to type aggregating sites and Wikipedia are _not acceptable_.

To update the build, run `npm run build`.

[ci-image]: https://badgen.net/github/checks/jshttp/mime-db/master?label=ci
[ci-url]: https://github.com/jshttp/mime-db/actions/workflows/ci.yml
[coveralls-image]: https://badgen.net/coveralls/c/github/jshttp/mime-db/master
[coveralls-url]: https://coveralls.io/r/jshttp/mime-db?branch=master
[node-image]: https://badgen.net/npm/node/mime-db
[node-url]: https://nodejs.org/en/download
[npm-downloads-image]: https://badgen.net/npm/dm/mime-db
[npm-url]: https://npmjs.org/package/mime-db
[npm-version-image]: https://badgen.net/npm/v/mime-db

--- /home/labo/Bureau/Projet_Web/script/debug_report.txt ---
=== DEBUG REPORT ===

=== 1) Arborescence compl√®te du projet ===

=== 2) Fichiers contenant 'db.js' ===
/home/labo/Bureau/Projet_Web/event-backend/src/authController.js:11:import pool from "../db.js";
/home/labo/Bureau/Projet_Web/event-backend/src/createUser.js:7:import pool from "../db.js";       // Connexion PostgreSQL
/home/labo/Bureau/Projet_Web/event-backend/userManager.js:3:import pool from "././src/db.js";
/home/labo/Bureau/Projet_Web/event-backend/node_modules/pg-pool/README.md:193:// assume this is a file in your program at ./your-app/lib/db.js
/home/labo/Bureau/Projet_Web/event-backend/node_modules/mime-db/package.json:40:    "db.json",
/home/labo/Bureau/Projet_Web/event-backend/node_modules/mime-db/index.js:12:module.exports = require('./db.json')
/home/labo/Bureau/Projet_Web/event-backend/node_modules/mime-db/README.md:29:https://cdn.jsdelivr.net/gh/jshttp/mime-db@master/db.json
/home/labo/Bureau/Projet_Web/script/generate_debug_report.sh:12:echo "=== 2) Fichiers contenant 'db.js' ===" >> $OUTPUT
/home/labo/Bureau/Projet_Web/script/generate_debug_report.sh:13:grep -RIn "db.js" ~/Bureau/Projet_Web >> $OUTPUT 2>/dev/null
/home/labo/Bureau/Projet_Web/script/generate_debug_report.sh:18:FILES=$(grep -RIl "db.js" ~/Bureau/Projet_Web)

=== 3) Contenu des fichiers suspects ===
--- /home/labo/Bureau/Projet_Web/event-backend/src/authController.js ---
// Importation de bcrypt : sert √† hasher les mots de passe
// ‚Üí On ne stocke jamais un mot de passe en clair dans la base
import bcrypt from "bcryptjs";

// Importation de jsonwebtoken : sert √† cr√©er et v√©rifier les tokens JWT
// ‚Üí Le token permet d'identifier un utilisateur connect√©
import jwt from "jsonwebtoken";

// Importation du pool PostgreSQL (connexion √† la base)
// ‚Üí pool.query() permet d'ex√©cuter des requ√™tes SQL
import pool from "../db.js";

// Importation de dotenv : permet de lire les variables du fichier .env
import dotenv from "dotenv";

// Charge les variables du fichier .env dans process.env
dotenv.config();

// R√©cup√©ration de la cl√© secr√®te utilis√©e pour signer les tokens JWT
// ‚Üí Cette cl√© doit rester secr√®te et ne jamais √™tre dans le code
const JWT_SECRET = process.env.JWT_SECRET;



// ======================================================
//   INSCRIPTION (signup)
// ======================================================

// Fonction appel√©e quand un utilisateur veut cr√©er un compte
export const signup = async (req, res) => {
  // R√©cup√©ration des donn√©es envoy√©es par le frontend
  const { username, password } = req.body;

  try {
    // V√©rifie que les deux champs sont bien fournis
    if (!username || !password) {
      return res.status(400).json({ error: "Missing username or password" });
    }

    // V√©rifie si un utilisateur avec ce username existe d√©j√†
    // $1 = premier param√®tre du tableau [username]
    const existingUser = await pool.query(
      "SELECT * FROM users WHERE username = $1",
      [username]
    );

    // Si un utilisateur existe d√©j√†, on bloque l'inscription
    if (existingUser.rows.length > 0) {
      return res.status(400).json({ error: "User already exists" });
    }

    // Hashage du mot de passe
    // 10 = nombre de "rounds" de s√©curit√©
    const hashedPassword = await bcrypt.hash(password, 10);

    // Insertion du nouvel utilisateur dans la base
    // RETURNING permet de r√©cup√©rer l'id et le username cr√©√©s
    const newUser = await pool.query(
      "INSERT INTO users (username, password) VALUES ($1, $2) RETURNING id, username",
      [username, hashedPassword]
    );

    // Cr√©ation d'un token JWT contenant l'id et le username
    // expiresIn: "7d" ‚Üí le token expire dans 7 jours
    const token = jwt.sign(
      { id: newUser.rows[0].id, username: newUser.rows[0].username },
      JWT_SECRET,
      { expiresIn: "7d" }
    );

    // R√©ponse envoy√©e au frontend
    res.json({
      message: "User created successfully",
      token,
      user: newUser.rows[0],
    });

  } catch (err) {
    // Si une erreur survient, on l'affiche dans la console
    console.error("Signup error:", err);

    // Et on renvoie une erreur g√©n√©rique au frontend
    res.status(500).json({ error: "Internal server error" });
  }
};



// ======================================================
//   CONNEXION (login)
// ======================================================

// Fonction appel√©e quand un utilisateur veut se connecter
export const login = async (req, res) => {
  const { username, password } = req.body;

  try {
    // V√©rifie que les champs sont fournis
    if (!username || !password) {
      return res.status(400).json({ error: "Missing username or password" });
    }

    // Recherche de l'utilisateur dans la base
    const user = await pool.query(
      "SELECT * FROM users WHERE username = $1",
      [username]
    );

    // Si aucun utilisateur trouv√© ‚Üí identifiants invalides
    if (user.rows.length === 0) {
      return res.status(400).json({ error: "Invalid credentials" });
    }

    // On r√©cup√®re l'utilisateur trouv√©
    const storedUser = user.rows[0];

    // V√©rifie si le mot de passe fourni correspond au hash stock√©
    const isMatch = await bcrypt.compare(password, storedUser.password);

    // Si le mot de passe ne correspond pas ‚Üí erreur
    if (!isMatch) {
      return res.status(400).json({ error: "Invalid credentials" });
    }

    // G√©n√©ration d'un token JWT pour cet utilisateur
    const token = jwt.sign(
      { id: storedUser.id, username: storedUser.username },
      JWT_SECRET,
      { expiresIn: "7d" }
    );

    // R√©ponse envoy√©e au frontend
    res.json({
      message: "Login successful",
      token,
      user: { id: storedUser.id, username: storedUser.username },
    });

  } catch (err) {
    console.error("Login error:", err);
    res.status(500).json({ error: "Internal server error" });
  }
};



// ======================================================
//   PROFIL UTILISATEUR (prot√©g√© par requireAuth)
// ======================================================

// Cette route renvoie les infos de l'utilisateur connect√©
// requireAuth ajoute req.user automatiquement
export const getProfile = async (req, res) => {
  try {
    res.json({
      message: "Authenticated user",
      user: req.user, // Contient { id, username }
    });
  } catch (err) {
    res.status(500).json({ error: "Internal server error" });
  }
};

--- /home/labo/Bureau/Projet_Web/event-backend/src/createUser.js ---
// Script interne permettant √† un d√©veloppeur de cr√©er un utilisateur manuellement
// ------------------------------------------------------------------------------

// Importation des modules n√©cessaires
import readline from "readline";   // Pour lire les entr√©es clavier
import bcrypt from "bcryptjs";     // Pour hasher le mot de passe
import pool from "../db.js";       // Connexion PostgreSQL

// Interface pour lire les entr√©es utilisateur dans le terminal
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

// Fonction utilitaire pour poser une question dans le terminal
function ask(question) {
  return new Promise((resolve) => rl.question(question, resolve));
}

--- /home/labo/Bureau/Projet_Web/script/generate_debug_report.sh ---
#!/bin/bash

OUTPUT="debug_report.txt"

echo "=== DEBUG REPORT ===" > $OUTPUT
echo "" >> $OUTPUT

echo "=== 1) Arborescence compl√®te du projet ===" >> $OUTPUT
tree -a ~/Bureau/Projet_Web >> $OUTPUT 2>/dev/null
echo "" >> $OUTPUT

echo "=== 2) Fichiers contenant 'db.js' ===" >> $OUTPUT
grep -RIn "db.js" ~/Bureau/Projet_Web >> $OUTPUT 2>/dev/null
echo "" >> $OUTPUT

echo "=== 3) Contenu des fichiers suspects ===" >> $OUTPUT

FILES=$(grep -RIl "db.js" ~/Bureau/Projet_Web)

for f in $FILES; do
    echo "--- $f ---" >> $OUTPUT
    sed -n '1,200p' "$f" >> $OUTPUT
    echo "" >> $OUTPUT
done

echo "=== FIN DU RAPPORT ===" >> $OUTPUT

echo "Rapport g√©n√©r√© dans : $OUTPUT"

=== FIN DU RAPPORT ===
